"""Seed database with synthetic data generated by Julia core."""

from __future__ import annotations

import asyncio
import math
import uuid
from collections.abc import Iterable
from dataclasses import dataclass
from datetime import UTC, datetime, timedelta
from time import perf_counter
from typing import Any

from sqlalchemy import delete, insert

from app.database import async_session_factory, engine
from app.models.crops import CropProfile
from app.models.enums import (
	AnomalyTypeEnum,
	FarmTypeEnum,
	HyperEdgeLayerEnum,
	IrrigationTriggerEnum,
	NpkSourceEnum,
	VertexTypeEnum,
	ZoneTypeEnum,
)
from app.models.farm import Farm, HyperEdge, Vertex, Zone
from app.models.sensors import (
	IrrigationEvent,
	LightingReading,
	NpkSample,
	SoilReading,
	VisionEvent,
	WeatherReading,
)
from app.services import julia_bridge

SEED_NAMESPACE = uuid.UUID("8b0b4d61-2af1-47f6-9d3a-8cbbe5df4abc")


@dataclass(slots=True)
class SeedArtifacts:
	farm_id: uuid.UUID
	zone_ids: dict[str, uuid.UUID]
	zone_types: dict[str, ZoneTypeEnum]
	zone_area_m2: dict[str, float]
	soil_sensor_ids: list[uuid.UUID]
	soil_sensor_zones: list[str]
	weather_station_ids: list[uuid.UUID]
	valve_ids: list[uuid.UUID]
	fixture_ids: list[uuid.UUID]
	fixture_zones: list[str]
	bed_ids: list[uuid.UUID]
	bed_zones: list[str]
	camera_ids: list[uuid.UUID]
	camera_for_bed: list[int]


def _stable_uuid(token: str) -> uuid.UUID:
	return uuid.uuid5(SEED_NAMESPACE, token)


def _is_missing(value: Any) -> bool:
	if value is None:
		return True
	if isinstance(value, float):
		return math.isnan(value)
	return False


def _matrix_value(matrix: list[list[Any]], row: int, col: int) -> Any:
	return matrix[row][col]


async def _bulk_insert(
	session: Any,
	model: Any,
	rows: Iterable[dict[str, Any]],
	chunk_size: int = 5000,
) -> int:
	batch: list[dict[str, Any]] = []
	count = 0
	for row in rows:
		batch.append(row)
		if len(batch) >= chunk_size:
			await session.execute(insert(model), batch)
			count += len(batch)
			batch.clear()
	if batch:
		await session.execute(insert(model), batch)
		count += len(batch)
	return count


def _crop_profiles() -> list[CropProfile]:
	payloads = [
		{
			"crop_type": "tomato",
			"source": "FAO",
			"growth_stages": {
				"seedling": {"duration_days": 14, "water_demand_mm_day": 2.5, "npk_demand": {"n": 35, "p": 18, "k": 28}},
				"vegetative": {"duration_days": 30, "water_demand_mm_day": 4.5, "npk_demand": {"n": 55, "p": 25, "k": 45}},
				"fruiting": {"duration_days": 35, "water_demand_mm_day": 5.8, "npk_demand": {"n": 45, "p": 30, "k": 60}},
			},
		},
		{
			"crop_type": "lettuce",
			"source": "FAO",
			"growth_stages": {
				"seedling": {"duration_days": 10, "water_demand_mm_day": 2.0, "npk_demand": {"n": 25, "p": 16, "k": 20}},
				"leafing": {"duration_days": 25, "water_demand_mm_day": 3.2, "npk_demand": {"n": 35, "p": 20, "k": 28}},
			},
		},
		{
			"crop_type": "pepper",
			"source": "FAO",
			"growth_stages": {
				"seedling": {"duration_days": 14, "water_demand_mm_day": 2.3, "npk_demand": {"n": 30, "p": 16, "k": 24}},
				"flowering": {"duration_days": 30, "water_demand_mm_day": 4.2, "npk_demand": {"n": 40, "p": 24, "k": 45}},
				"fruiting": {"duration_days": 36, "water_demand_mm_day": 5.2, "npk_demand": {"n": 38, "p": 28, "k": 55}},
			},
		},
	]
	return [CropProfile(**item) for item in payloads]


def _build_topology(synthetic: dict[str, Any]) -> SeedArtifacts:
	topology = synthetic["topology"]
	zone_defs: list[dict[str, Any]] = topology["zones"]
	farm_id = _stable_uuid("farm:demo_hybrid")

	zone_ids: dict[str, uuid.UUID] = {}
	zone_types: dict[str, ZoneTypeEnum] = {}
	zone_area_m2: dict[str, float] = {}
	greenhouse_area = 650.0
	open_field_area = 2800.0
	for zone in zone_defs:
		zone_token = str(zone["zone_id"])
		zone_ids[zone_token] = _stable_uuid(f"zone:{zone_token}")
		zone_type = ZoneTypeEnum.greenhouse if zone["zone_type"] == "greenhouse" else ZoneTypeEnum.open_field
		zone_types[zone_token] = zone_type
		zone_area_m2[zone_token] = greenhouse_area if zone_type == ZoneTypeEnum.greenhouse else open_field_area

	soil_sensor_names: list[str] = list(topology["soil_sensors"]["sensor_id"])
	soil_sensor_zones: list[str] = list(topology["soil_sensors"]["zone_id"])
	soil_sensor_ids = [_stable_uuid(f"vertex:soil_sensor:{token}") for token in soil_sensor_names]

	station_names: list[str] = list(topology["weather_stations"]["station_id"])
	weather_station_ids = [_stable_uuid(f"vertex:weather_station:{token}") for token in station_names]

	zone_order = sorted(zone_ids.keys(), key=lambda value: int(value.split("_")[1]))
	valve_ids = [_stable_uuid(f"vertex:valve:{zone_token}") for zone_token in zone_order]

	lighting_layer = synthetic["layers"]["lighting"]
	n_fixtures = int(lighting_layer["n_sensors"])
	greenhouse_zones = [zone for zone in zone_order if zone_types[zone] == ZoneTypeEnum.greenhouse]
	fixture_ids = [_stable_uuid(f"vertex:light_fixture:{index + 1}") for index in range(n_fixtures)]
	fixture_zones = [greenhouse_zones[index % len(greenhouse_zones)] for index in range(n_fixtures)] if greenhouse_zones else []

	vision_layer = synthetic["layers"]["vision"]
	n_beds = int(vision_layer["n_beds"])
	n_cameras = int(vision_layer["n_cameras"])
	bed_ids = [_stable_uuid(f"vertex:crop_bed:{index + 1}") for index in range(n_beds)]
	bed_zones = [zone_order[index % len(zone_order)] for index in range(n_beds)]
	camera_ids = [_stable_uuid(f"vertex:camera:{index + 1}") for index in range(n_cameras)]
	camera_for_bed = [int(item) for item in list(vision_layer["camera_for_bed"])]

	return SeedArtifacts(
		farm_id=farm_id,
		zone_ids=zone_ids,
		zone_types=zone_types,
		zone_area_m2=zone_area_m2,
		soil_sensor_ids=soil_sensor_ids,
		soil_sensor_zones=soil_sensor_zones,
		weather_station_ids=weather_station_ids,
		valve_ids=valve_ids,
		fixture_ids=fixture_ids,
		fixture_zones=fixture_zones,
		bed_ids=bed_ids,
		bed_zones=bed_zones,
		camera_ids=camera_ids,
		camera_for_bed=camera_for_bed,
	)


async def _seed_topology(session: Any, synthetic: dict[str, Any], artifacts: SeedArtifacts) -> dict[str, int]:
	counts = {"farms": 0, "zones": 0, "vertices": 0, "hyperedges": 0, "crop_profiles": 0}

	farm = Farm(
		id=artifacts.farm_id,
		name="AgriSense Demo Hybrid Farm",
		farm_type=FarmTypeEnum.hybrid,
		timezone="UTC",
		model_overrides={"seed": int(synthetic["seed"]), "days": int(synthetic["days"]), "source": "synthetic"},
	)
	session.add(farm)
	counts["farms"] = 1

	zone_order = sorted(artifacts.zone_ids.keys(), key=lambda value: int(value.split("_")[1]))
	for zone_token in zone_order:
		session.add(
			Zone(
				id=artifacts.zone_ids[zone_token],
				farm_id=artifacts.farm_id,
				name=f"{zone_token.replace('_', ' ').title()}",
				zone_type=artifacts.zone_types[zone_token],
				area_m2=artifacts.zone_area_m2[zone_token],
				soil_type="loam" if artifacts.zone_types[zone_token] == ZoneTypeEnum.greenhouse else "sandy_loam",
				metadata_={"synthetic_zone_token": zone_token},
			)
		)
		counts["zones"] += 1

	soil_by_zone: dict[str, list[uuid.UUID]] = {zone: [] for zone in zone_order}
	for sensor_id, zone_token in zip(artifacts.soil_sensor_ids, artifacts.soil_sensor_zones, strict=True):
		soil_by_zone[zone_token].append(sensor_id)
		session.add(
			Vertex(
				id=sensor_id,
				farm_id=artifacts.farm_id,
				zone_id=artifacts.zone_ids[zone_token],
				vertex_type=VertexTypeEnum.sensor,
				config={"sensor_type": "soil", "synthetic": True},
			)
		)
		counts["vertices"] += 1

	for station_id in artifacts.weather_station_ids:
		session.add(
			Vertex(
				id=station_id,
				farm_id=artifacts.farm_id,
				zone_id=None,
				vertex_type=VertexTypeEnum.weather_station,
				config={"sensor_type": "weather", "synthetic": True},
			)
		)
		counts["vertices"] += 1

	for zone_token, valve_id in zip(zone_order, artifacts.valve_ids, strict=True):
		session.add(
			Vertex(
				id=valve_id,
				farm_id=artifacts.farm_id,
				zone_id=artifacts.zone_ids[zone_token],
				vertex_type=VertexTypeEnum.valve,
				config={"max_flow_lpm": 50.0, "synthetic": True},
			)
		)
		counts["vertices"] += 1

	for fixture_id, zone_token in zip(artifacts.fixture_ids, artifacts.fixture_zones, strict=True):
		session.add(
			Vertex(
				id=fixture_id,
				farm_id=artifacts.farm_id,
				zone_id=artifacts.zone_ids[zone_token],
				vertex_type=VertexTypeEnum.light_fixture,
				config={"spectrum_profile": "full", "synthetic": True},
			)
		)
		counts["vertices"] += 1

	for bed_id, zone_token in zip(artifacts.bed_ids, artifacts.bed_zones, strict=True):
		session.add(
			Vertex(
				id=bed_id,
				farm_id=artifacts.farm_id,
				zone_id=artifacts.zone_ids[zone_token],
				vertex_type=VertexTypeEnum.crop_bed,
				config={"crop": "tomato", "synthetic": True},
			)
		)
		counts["vertices"] += 1

	for camera_id in artifacts.camera_ids:
		session.add(
			Vertex(
				id=camera_id,
				farm_id=artifacts.farm_id,
				zone_id=None,
				vertex_type=VertexTypeEnum.camera,
				config={"model": "synthetic-cv", "synthetic": True},
			)
		)
		counts["vertices"] += 1

	bed_to_camera: dict[uuid.UUID, uuid.UUID] = {}
	for bed_id, camera_index in zip(artifacts.bed_ids, artifacts.camera_for_bed, strict=True):
		index = max(1, camera_index) - 1
		if index < len(artifacts.camera_ids):
			bed_to_camera[bed_id] = artifacts.camera_ids[index]

	for zone_token in zone_order:
		zone_id = artifacts.zone_ids[zone_token]
		zone_soil = soil_by_zone[zone_token]
		zone_valve = artifacts.valve_ids[zone_order.index(zone_token)]
		zone_fixtures = [fixture for fixture, fixture_zone in zip(artifacts.fixture_ids, artifacts.fixture_zones, strict=True) if fixture_zone == zone_token]
		zone_beds = [bed for bed, bed_zone in zip(artifacts.bed_ids, artifacts.bed_zones, strict=True) if bed_zone == zone_token]
		zone_cameras = sorted({bed_to_camera[bed] for bed in zone_beds if bed in bed_to_camera})

		edges: list[tuple[HyperEdgeLayerEnum, list[uuid.UUID], dict[str, Any]]] = [
			(HyperEdgeLayerEnum.soil, zone_soil, {"zone_id": str(zone_id)}),
			(HyperEdgeLayerEnum.irrigation, [zone_valve, *zone_soil], {"zone_id": str(zone_id)}),
			(HyperEdgeLayerEnum.weather, [*artifacts.weather_station_ids, *zone_soil], {"zone_id": str(zone_id)}),
			(HyperEdgeLayerEnum.npk, [*zone_soil, *zone_beds], {"zone_id": str(zone_id)}),
			(HyperEdgeLayerEnum.crop_requirements, zone_beds, {"zone_id": str(zone_id)}),
		]
		if zone_fixtures:
			edges.append((HyperEdgeLayerEnum.lighting, zone_fixtures, {"zone_id": str(zone_id)}))
		if zone_beds and zone_cameras:
			edges.append((HyperEdgeLayerEnum.vision, [*zone_beds, *zone_cameras], {"zone_id": str(zone_id)}))

		for layer, vertex_ids, metadata in edges:
			unique_vertices = list(dict.fromkeys(vertex_ids))
			if not unique_vertices:
				continue
			session.add(
				HyperEdge(
					id=_stable_uuid(f"edge:{layer.value}:{zone_token}"),
					farm_id=artifacts.farm_id,
					layer=layer,
					vertex_ids=unique_vertices,
					metadata_=metadata,
				)
			)
			counts["hyperedges"] += 1

	profiles = _crop_profiles()
	session.add_all(profiles)
	counts["crop_profiles"] = len(profiles)

	await session.flush()
	return counts


def _build_timestamps(days: int, n_steps: int, cadence_minutes: int) -> list[datetime]:
	start = datetime.now(UTC) - timedelta(days=days)
	return [start + timedelta(minutes=cadence_minutes * index) for index in range(n_steps)]


def _soil_rows(synthetic: dict[str, Any], artifacts: SeedArtifacts, timestamps: list[datetime]) -> Iterable[dict[str, Any]]:
	soil = synthetic["layers"]["soil"]
	moisture = soil["moisture"]
	temperature = soil["temperature"]
	conductivity = soil["conductivity"]
	ph = soil["ph"]

	for step, timestamp in enumerate(timestamps):
		for sensor_index, sensor_id in enumerate(artifacts.soil_sensor_ids):
			moisture_value = _matrix_value(moisture, step, sensor_index)
			temperature_value = _matrix_value(temperature, step, sensor_index)
			if _is_missing(moisture_value) or _is_missing(temperature_value):
				continue
			conductivity_value = _matrix_value(conductivity, step, sensor_index)
			ph_value = _matrix_value(ph, step, sensor_index)
			yield {
				"sensor_id": sensor_id,
				"timestamp": timestamp,
				"moisture": float(moisture_value),
				"temperature": float(temperature_value),
				"conductivity": None if _is_missing(conductivity_value) else float(conductivity_value),
				"ph": None if _is_missing(ph_value) else float(ph_value),
			}


def _weather_rows(synthetic: dict[str, Any], artifacts: SeedArtifacts, timestamps: list[datetime]) -> Iterable[dict[str, Any]]:
	weather = synthetic["layers"]["weather"]
	temperature = weather["temperature"]
	humidity = weather["humidity"]
	precipitation = weather["precipitation_mm"]
	wind_speed = weather["wind_speed"]
	wind_direction = weather["wind_direction"]
	pressure = weather["pressure_hpa"]
	et0 = weather["et0"]

	for step, timestamp in enumerate(timestamps):
		for station_index, station_id in enumerate(artifacts.weather_station_ids):
			temperature_value = _matrix_value(temperature, step, station_index)
			humidity_value = _matrix_value(humidity, step, station_index)
			precipitation_value = _matrix_value(precipitation, step, station_index)
			if _is_missing(temperature_value) or _is_missing(humidity_value) or _is_missing(precipitation_value):
				continue
			wind_speed_value = _matrix_value(wind_speed, step, station_index)
			wind_direction_value = _matrix_value(wind_direction, step, station_index)
			pressure_value = _matrix_value(pressure, step, station_index)
			et0_value = _matrix_value(et0, step, station_index)
			yield {
				"station_id": station_id,
				"timestamp": timestamp,
				"temperature": float(temperature_value),
				"humidity": float(humidity_value),
				"precipitation_mm": float(precipitation_value),
				"wind_speed": None if _is_missing(wind_speed_value) else float(wind_speed_value),
				"wind_direction": None if _is_missing(wind_direction_value) else float(wind_direction_value),
				"pressure_hpa": None if _is_missing(pressure_value) else float(pressure_value),
				"et0": None if _is_missing(et0_value) else float(et0_value),
			}


def _irrigation_rows(
	synthetic: dict[str, Any],
	artifacts: SeedArtifacts,
	timestamps: list[datetime],
	zone_tokens: list[str],
) -> Iterable[dict[str, Any]]:
	irrigation = synthetic["layers"]["irrigation"]
	applied = irrigation["applied_mm"]
	for step, timestamp in enumerate(timestamps):
		for valve_index, valve_id in enumerate(artifacts.valve_ids):
			mm_value = _matrix_value(applied, step, valve_index)
			if _is_missing(mm_value):
				continue
			value = float(mm_value)
			if value <= 0.0:
				continue
			zone_token = zone_tokens[valve_index]
			area = artifacts.zone_area_m2[zone_token]
			volume_liters = value * area
			yield {
				"valve_id": valve_id,
				"timestamp_start": timestamp,
				"timestamp_end": timestamp + timedelta(minutes=5),
				"volume_liters": float(volume_liters),
				"trigger": IrrigationTriggerEnum.auto,
			}


def _npk_rows(synthetic: dict[str, Any], artifacts: SeedArtifacts, days: int) -> Iterable[dict[str, Any]]:
	npk = synthetic["layers"]["npk"]
	nitrogen = npk["nitrogen_mg_kg"]
	phosphorus = npk["phosphorus_mg_kg"]
	potassium = npk["potassium_mg_kg"]
	organic = npk["organic_matter_pct"]
	zone_tokens = sorted(artifacts.zone_ids.keys(), key=lambda value: int(value.split("_")[1]))
	n_weeks = int(npk["n_weeks"])
	start = datetime.now(UTC) - timedelta(days=days)

	for week in range(n_weeks):
		timestamp = start + timedelta(days=7 * week)
		for zone_index, zone_token in enumerate(zone_tokens):
			n_value = _matrix_value(nitrogen, week, zone_index)
			p_value = _matrix_value(phosphorus, week, zone_index)
			k_value = _matrix_value(potassium, week, zone_index)
			if _is_missing(n_value) or _is_missing(p_value) or _is_missing(k_value):
				continue
			organic_value = _matrix_value(organic, week, zone_index)
			yield {
				"zone_id": artifacts.zone_ids[zone_token],
				"timestamp": timestamp,
				"nitrogen_mg_kg": float(n_value),
				"phosphorus_mg_kg": float(p_value),
				"potassium_mg_kg": float(k_value),
				"organic_matter_pct": None if _is_missing(organic_value) else float(organic_value),
				"source": NpkSourceEnum.inline_sensor,
			}


def _lighting_rows(synthetic: dict[str, Any], artifacts: SeedArtifacts, timestamps: list[datetime]) -> Iterable[dict[str, Any]]:
	lighting = synthetic["layers"]["lighting"]
	if not artifacts.fixture_ids:
		return []

	par = lighting["par_umol"]
	dli = lighting["dli_cumulative"]
	duty = lighting["duty_cycle_pct"]
	spectrum = lighting["spectrum_index"]

	def iterator() -> Iterable[dict[str, Any]]:
		for step, timestamp in enumerate(timestamps):
			for fixture_index, fixture_id in enumerate(artifacts.fixture_ids):
				par_value = _matrix_value(par, step, fixture_index)
				dli_value = _matrix_value(dli, step, fixture_index)
				duty_value = _matrix_value(duty, step, fixture_index)
				if _is_missing(par_value) or _is_missing(dli_value) or _is_missing(duty_value):
					continue
				spectrum_value = _matrix_value(spectrum, step, fixture_index)
				yield {
					"fixture_id": fixture_id,
					"timestamp": timestamp,
					"par_umol": float(par_value),
					"dli_cumulative": float(dli_value),
					"duty_cycle_pct": float(duty_value),
					"spectrum_profile": {
						"index": None if _is_missing(spectrum_value) else float(spectrum_value)
					},
				}

	return iterator()


def _vision_rows(synthetic: dict[str, Any], artifacts: SeedArtifacts, timestamps: list[datetime]) -> Iterable[dict[str, Any]]:
	vision = synthetic["layers"]["vision"]
	anomaly = vision["anomaly_code"]
	confidence = vision["confidence"]
	canopy = vision["canopy_coverage_pct"]

	def map_anomaly(code: int) -> AnomalyTypeEnum:
		if code == 1:
			return AnomalyTypeEnum.pest
		if code == 2:
			return AnomalyTypeEnum.disease
		return AnomalyTypeEnum.none

	for step, timestamp in enumerate(timestamps):
		for bed_index, bed_id in enumerate(artifacts.bed_ids):
			anomaly_code = int(_matrix_value(anomaly, step, bed_index))
			confidence_value = _matrix_value(confidence, step, bed_index)
			if anomaly_code < 0 or _is_missing(confidence_value):
				continue
			canopy_value = _matrix_value(canopy, step, bed_index)
			camera_idx = max(1, artifacts.camera_for_bed[bed_index]) - 1
			if camera_idx >= len(artifacts.camera_ids):
				continue
			yield {
				"camera_id": artifacts.camera_ids[camera_idx],
				"crop_bed_id": bed_id,
				"timestamp": timestamp,
				"anomaly_type": map_anomaly(anomaly_code),
				"confidence": float(confidence_value),
				"canopy_coverage_pct": None if _is_missing(canopy_value) else float(canopy_value),
				"metadata": {"synthetic": True, "anomaly_code": anomaly_code},
			}


async def _clear_existing_data(session: Any) -> None:
	await session.execute(delete(SoilReading))
	await session.execute(delete(WeatherReading))
	await session.execute(delete(IrrigationEvent))
	await session.execute(delete(NpkSample))
	await session.execute(delete(VisionEvent))
	await session.execute(delete(LightingReading))
	await session.execute(delete(HyperEdge))
	await session.execute(delete(Vertex))
	await session.execute(delete(Zone))
	await session.execute(delete(Farm))
	await session.execute(delete(CropProfile))


async def seed_database() -> dict[str, Any]:
	timings: dict[str, float] = {}
	counts: dict[str, int] = {}

	t0 = perf_counter()
	synthetic = julia_bridge.generate_synthetic(farm_type="hybrid", days=90, seed=42)
	timings["generate_synthetic_ms"] = round((perf_counter() - t0) * 1000.0, 2)

	artifacts = _build_topology(synthetic)
	cadence_minutes = int(synthetic["cadence_minutes"])
	n_steps = int(synthetic["n_steps"])
	days = int(synthetic["days"])
	timestamps = _build_timestamps(days=days, n_steps=n_steps, cadence_minutes=cadence_minutes)
	zone_tokens = sorted(artifacts.zone_ids.keys(), key=lambda value: int(value.split("_")[1]))

	async with async_session_factory() as session:
		clear_start = perf_counter()
		await _clear_existing_data(session)
		timings["clear_existing_ms"] = round((perf_counter() - clear_start) * 1000.0, 2)

		topo_start = perf_counter()
		topo_counts = await _seed_topology(session, synthetic, artifacts)
		counts.update(topo_counts)
		timings["topology_ms"] = round((perf_counter() - topo_start) * 1000.0, 2)

		soil_start = perf_counter()
		counts["soil_readings"] = await _bulk_insert(session, SoilReading, _soil_rows(synthetic, artifacts, timestamps))
		timings["soil_ms"] = round((perf_counter() - soil_start) * 1000.0, 2)

		weather_start = perf_counter()
		counts["weather_readings"] = await _bulk_insert(session, WeatherReading, _weather_rows(synthetic, artifacts, timestamps))
		timings["weather_ms"] = round((perf_counter() - weather_start) * 1000.0, 2)

		irrigation_start = perf_counter()
		counts["irrigation_events"] = await _bulk_insert(session, IrrigationEvent, _irrigation_rows(synthetic, artifacts, timestamps, zone_tokens))
		timings["irrigation_ms"] = round((perf_counter() - irrigation_start) * 1000.0, 2)

		npk_start = perf_counter()
		counts["npk_samples"] = await _bulk_insert(session, NpkSample, _npk_rows(synthetic, artifacts, days=days))
		timings["npk_ms"] = round((perf_counter() - npk_start) * 1000.0, 2)

		lighting_start = perf_counter()
		counts["lighting_readings"] = await _bulk_insert(session, LightingReading, _lighting_rows(synthetic, artifacts, timestamps))
		timings["lighting_ms"] = round((perf_counter() - lighting_start) * 1000.0, 2)

		vision_start = perf_counter()
		counts["vision_events"] = await _bulk_insert(session, VisionEvent, _vision_rows(synthetic, artifacts, timestamps))
		timings["vision_ms"] = round((perf_counter() - vision_start) * 1000.0, 2)

		await session.commit()

	total_ms = round((perf_counter() - t0) * 1000.0, 2)
	report = {
		"status": "ok",
		"farm_id": str(artifacts.farm_id),
		"duration_ms": total_ms,
		"duration_s": round(total_ms / 1000.0, 2),
		"counts": counts,
		"timings": timings,
		"target_under_30s": total_ms < 30_000,
	}
	return report


async def _async_main() -> None:
	try:
		report = await seed_database()
	except Exception as exc:
		print("=== AgriSense Seed Report ===")
		print("status: failed")
		print(f"error: {exc}")
		print("hint: ensure PostgreSQL/Redis are running and DATABASE_URL/REDIS_URL are correct")
		raise SystemExit(1) from exc
	finally:
		await engine.dispose()

	print("=== AgriSense Seed Report ===")
	print(f"status: {report['status']}")
	print(f"farm_id: {report['farm_id']}")
	print(f"duration_s: {report['duration_s']} (target<30s: {report['target_under_30s']})")
	print("counts:")
	for key, value in sorted(report["counts"].items()):
		print(f"  - {key}: {value}")
	print("timings_ms:")
	for key, value in sorted(report["timings"].items()):
		print(f"  - {key}: {value}")


def main() -> None:
	asyncio.run(_async_main())


if __name__ == "__main__":
	main()
